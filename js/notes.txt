Phaser Follower on Path
follower = { t: 0, vec: new Phaser.Math.Vector2() };

path = new Phaser.Curves.Path();

path.add(new Phaser.Curves.Ellipse(400, 300, 100));

this.tweens.add({
    targets: follower,
    t: 1,
    ease: 'Sine.easeInOut',
    duration: 4000,
    yoyo: true,
    repeat: -1
});
/////////////////////////////////////////////////////




 * Generates a texture based on the given Create configuration object.
 * 
 * The texture is drawn using a fixed-size indexed palette of 16 colors, where the hex value in the
 * data cells map to a single color. For example, if the texture config looked like this:
 *
 * ```javascript
 * var star = [
 *   '.....828.....',
 *   '....72227....',
 *   '....82228....',
 *   '...7222227...',
 *   '2222222222222',
 *   '8222222222228',
 *   '.72222222227.',
 *   '..787777787..',
 *   '..877777778..',
 *   '.78778887787.',
 *   '.27887.78872.',
 *   '.787.....787.'
 * ];
 * 
 * this.textures.generate('star', { data: star, pixelWidth: 4 });
 * ```
 * 
 * Then it would generate a texture that is 52 x 48 pixels in size, because each cell of the data array
 * represents 1 pixel multiplied by the `pixelWidth` value. The cell values, such as `8`, maps to color
 * number 8 in the palette. If a cell contains a period character `.` then it is transparent.
 * 
 * The default palette is Arne16, but you can specify your own using the `palette` property.





// full implementation for boss shield (levels 40+)
var config = {
    type: Phaser.AUTO,
    width: 720,
    height: 1080,
    backgroundColor: '#2d2d2d',
    parent: 'phaser-example',
    scene: {
        preload: preload,
        create: create
    }
};

var game = new Phaser.Game(config);

function preload ()
{
    this.load.spritesheet('lemming', 'assets/sprites/balls.png', { frameWidth: 17, frameHeight: 17});
    this.load.image('brush', 'assets/sprites/brush1.png');
}

function create () {
    bossShieldContainer = this.add.container(360,450);
    console.log(bossShieldContainer.x);
    let width=260;
    let outerPath = new Phaser.Curves.Path(0+260, 0).circleTo(width);
    width=210;
    let middlePath = new Phaser.Curves.Path(0+210, 0).circleTo(width);
    width = 150;
    let innerPath = new Phaser.Curves.Path(0+150, 0).circleTo(width,true);
    
    let wave = 40;
    let shieldCoverage = -1;
    switch (wave) {
        case 40: // boss 0
            shieldCoverage = 0.4;
        break;
        case 41: // boss 1
            shieldCoverage = 0.5;
        break;
        case 42: // boss 2
            shieldCoverage = 0.6;
        break;
        case 43: // boss 3
            shieldCoverage = 0.7;
        break;
        case 44: // boss 4
            shieldCoverage = 0.8;
        break;
        case 45: // boss 5
            shieldCoverage = 0.9;
        break;
        case 46: // boss 6
            shieldCoverage = 1;
        break;
    }

    let tint = 0xffffff;
    let delay = 150;
    let duration = 3000;
    let max= ~~(duration/delay);
    let allowed = (max*shieldCoverage);
    for (let f=0; f<allowed; f++) {
        let brush = this.add.follower(middlePath, 0, 0, 'brush').setScale(1).setTint(tint);
        bossShieldContainer.add(brush)
        brush.startFollow({
            delay: f*delay,
            positionOnPath: true,
            duration: duration,
            repeat: -1,
        });
    }

    tint = 0xff0000;
    duration = 2000;
    max= ~~(duration/delay);
    allowed = (max*shieldCoverage);
        for (let f=0; f<allowed; f++) {
        let brush = this.add.follower(innerPath, 0, 0, 'brush').setScale(1).setTint(tint);
        bossShieldContainer.add(brush)
        brush.startFollow({
            delay: f*delay,
            positionOnPath: true,
            duration: duration,
            repeat: -1,
        });
    }

    tint = 0x0000FF;
    duration = 2000;
    delay = 100;
    max= ~~(duration/delay+0.5);
    allowed = max;
    console.log(allowed);
        for (let f=0; f<allowed; f++) {
        let brush = this.add.follower(outerPath, 0, 0, 'brush').setScale(0.5).setTint(tint);
        bossShieldContainer.add(brush)
        brush.startFollow({
            delay: f*delay,
            positionOnPath: true,
            duration: duration,
            repeat: -1,
        });
    }


}












// TUNNEL SHADER FULL SCRIPT

var config = {
    type: Phaser.WEBGL,
    parent: 'phaser-example',
    width: 720,
    height: 1080,
    scene: {
        preload: preload,
        create: create
    }
};

var game = new Phaser.Game(config);

function preload () {
    this.load.image('alien', 'assets/textures/alien-metal.jpg');
    this.load.image('rock-ore', 'assets/textures/rock-ore.jpg');
    this.load.image('grass', 'assets/textures/grass.png');
    this.load.image('marble', 'assets/textures/blue-marble.jpg');
    this.load.image('soil', 'assets/textures/soil.png');

    this.load.image('ice', 'assets/textures/ice.png');
    this.load.image('grass2', 'assets/textures/grass2.png');
    this.load.image('sand', 'assets/textures/sand2.png');
    this.load.image('tiles', 'assets/textures/tiles2.png');
    this.load.image('water', 'assets/textures/water2.png');

    this.load.glsl('bundle', 'assets/shaders/bundle.glsl.js');
}

function create () {
    var s = this.add.shader('Tunnel', 360, 540, 720, 1080, [ 'alien' ]);

    s.setInteractive();

    s.on('pointerdown', function () {
        if (s.uniforms.iChannel0.textureKey === 'alien') {
            s.setChannel0('rock-ore');
        } else if (s.uniforms.iChannel0.textureKey === 'rock-ore') {
            s.setChannel0('soil');
        } else if (s.uniforms.iChannel0.textureKey === 'soil') {
            s.setChannel0('grass2');
        } else if (s.uniforms.iChannel0.textureKey === 'grass2') {
            s.setChannel0('tiles');
        } else if (s.uniforms.iChannel0.textureKey === 'tiles') {
            s.setChannel0('water');
        } else {
            s.setChannel0('alien');
        }
    });
}